var m=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var D=Object.getOwnPropertyNames;var K=Object.prototype.hasOwnProperty;var L=t=>m(t,"__esModule",{value:!0});var M=(t,e)=>{for(var s in e)m(t,s,{get:e[s],enumerable:!0})},R=(t,e,s,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of D(e))!K.call(t,r)&&(s||r!=="default")&&m(t,r,{get:()=>e[r],enumerable:!(n=I(e,r))||n.enumerable});return t};var z=(t=>(e,s)=>t&&t.get(e)||(s=R(L({}),e,1),t&&t.set(e,s),s))(typeof WeakMap!="undefined"?new WeakMap:0);var X={};M(X,{default:()=>j});var P=/-(\w)/g,A=t=>t.replace(P,(e,s)=>s.toUpperCase()),$=/\B([A-Z])/g,B=t=>t.replace($,"-$1").toLowerCase(),{stringify:u}=JSON,{hasOwnProperty:U}=Object.prototype,F=(t,e)=>U.call(t,e),W=/^--?/,q=/[.:=]/,C=t=>{let e=t.replace(W,""),s,n=e.match(q);if(n==null?void 0:n.index){let r=n.index;s=e.slice(r+1),e=e.slice(0,r)}return{flagName:e,flagValue:s}},G=/[\s.:=]/,J=(t,e)=>{let s=`Invalid flag name ${u(e)}:`;if(e.length===0)throw new Error(`${s} flag name cannot be empty}`);if(e.length===1)throw new Error(`${s} single characters are reserved for aliases`);let n=e.match(G);if(n)throw new Error(`${s} flag name cannot contain the character ${u(n==null?void 0:n[0])}`);let r;if(P.test(e)?r=A(e):$.test(e)&&(r=B(e)),r&&F(t,r))throw new Error(`${s} collides with flag ${u(r)}`)};function E(t){let e=new Map;for(let s in t){if(!F(t,s))continue;J(t,s);let n=t[s];if(n&&typeof n=="object"){let{alias:r}=n;if(typeof r=="string"){if(r.length===0)throw new Error(`Invalid flag alias ${u(s)}: flag alias cannot be empty`);if(r.length>1)throw new Error(`Invalid flag alias ${u(s)}: flag aliases can only be a single-character`);if(e.has(r))throw new Error(`Flag collision: Alias "${r}" is already used`);e.set(r,{name:s,schema:n})}}}return e}var Z=t=>!t||typeof t=="function"?!1:Array.isArray(t)||Array.isArray(t.type),v=t=>{let e={};for(let s in t)F(t,s)&&(e[s]=Z(t[s])?[]:void 0);return e},h=(t,e)=>t===Number&&e===""?Number.NaN:t===Boolean?e!=="false":e,_=(t,e)=>{for(let s in t){if(!F(t,s))continue;let n=t[s];if(!n)continue;let r=e[s];if(!(r!==void 0&&!(Array.isArray(r)&&r.length===0))&&"default"in n){let g=n.default;typeof g=="function"&&(g=g()),e[s]=g}}},x=(t,e)=>{if(!e)throw new Error(`Missing type on flag "${t}"`);return typeof e=="function"?e:Array.isArray(e)?e[0]:x(t,e.type)};var H=/^-[\da-z]+/i,Q=/^--[\w-]{2,}/,S="--";function j(t,e=process.argv.slice(2)){let s=E(t),n={flags:v(t),unknownFlags:{},_:Object.assign([],{[S]:[]})},r,g=(a,o,i)=>{let l=x(a,o);i=h(l,i),i!==void 0&&!Number.isNaN(i)?Array.isArray(n.flags[a])?n.flags[a].push(l(i)):n.flags[a]=l(i):r=c=>{Array.isArray(n.flags[a])?n.flags[a].push(l(h(l,c||""))):n.flags[a]=l(h(l,c||"")),r=void 0}},b=(a,o)=>{a in n.unknownFlags||(n.unknownFlags[a]=[]),o!==void 0?n.unknownFlags[a].push(o):r=(i=!0)=>{n.unknownFlags[a].push(i),r=void 0}};for(let a=0;a<e.length;a+=1){let o=e[a];if(o===S){let c=e.slice(a+1);n._[S]=c,n._.push(...c);break}let i=H.test(o);if(Q.test(o)||i){r&&r();let c=C(o),{flagValue:d}=c,{flagName:f}=c;if(i){for(let y=0;y<f.length;y+=1){let T=f[y],w=s.get(T),O=y===f.length-1;w?g(w.name,w.schema,O?d:!0):b(T,O?d:!0)}continue}let p=t[f];if(!p){let y=A(f);p=t[y],p&&(f=y)}if(!p){b(f,d);continue}g(f,p,d)}else r?r(o):n._.push(o)}return r&&r(),_(t,n.flags),n}module.exports=z(X);0&&(module.exports={});
