var m=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var K=Object.getOwnPropertyNames;var _=Object.prototype.hasOwnProperty;var D=t=>m(t,"__esModule",{value:!0});var M=(t,e)=>{for(var n in e)m(t,n,{get:e[n],enumerable:!0})},R=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of K(e))!_.call(t,s)&&(n||s!=="default")&&m(t,s,{get:()=>e[s],enumerable:!(r=j(e,s))||r.enumerable});return t};var z=(t=>(e,n)=>t&&t.get(e)||(n=R(D({}),e,1),t&&t.set(e,n),n))(typeof WeakMap!="undefined"?new WeakMap:0);var Q={};M(Q,{default:()=>I});var P=/-(\w)/g,A=t=>t.replace(P,(e,n)=>n.toUpperCase()),$=/\B([A-Z])/g,B=t=>t.replace($,"-$1").toLowerCase(),{stringify:u}=JSON,{hasOwnProperty:L}=Object.prototype,F=(t,e)=>L.call(t,e),U=/^--?/,W=/[.:=]/,C=t=>{let e=t.replace(U,""),n,r=e.match(W);if(r==null?void 0:r.index){let s=r.index;n=e.slice(s+1),e=e.slice(0,s)}return{flagName:e,flagValue:n}},q=/[\s.:=]/,J=(t,e)=>{let n=`Invalid flag name ${u(e)}:`;if(e.length===0)throw new Error(`${n} flag name cannot be empty}`);if(e.length===1)throw new Error(`${n} single characters are reserved for aliases`);let r=e.match(q);if(r)throw new Error(`${n} flag name cannot contain the character ${u(r==null?void 0:r[0])}`);let s;if(P.test(e)?s=A(e):$.test(e)&&(s=B(e)),s&&F(t,s))throw new Error(`${n} collides with flag ${u(s)}`)};function O(t){let e=new Map;for(let n in t){if(!F(t,n))continue;J(t,n);let r=t[n];if(r&&typeof r=="object"){let{alias:s}=r;if(typeof s=="string"){if(s.length===0)throw new Error(`Invalid flag alias ${u(n)}: flag alias cannot be empty`);if(s.length>1)throw new Error(`Invalid flag alias ${u(n)}: flag aliases can only be a single-character`);if(e.has(s))throw new Error(`Flag collision: Alias "${s}" is already used`);e.set(s,{name:n,schema:r})}}}return e}var Z=t=>!t||typeof t=="function"?!1:Array.isArray(t)||Array.isArray(t.type),E=t=>{let e={};for(let n in t)F(t,n)&&(e[n]=Z(t[n])?[]:void 0);return e},h=(t,e)=>t===Number&&e===""?Number.NaN:t===Boolean?e!=="false":e,v=(t,e)=>{for(let n in t){if(!F(t,n))continue;let r=t[n];if(!r)continue;let s=e[n];if(!(s!==void 0&&!(Array.isArray(s)&&s.length===0))&&"default"in r){let f=r.default;typeof f=="function"&&(f=f()),e[n]=f}}},x=(t,e)=>{if(!e)throw new Error(`Missing type on flag "${t}"`);return typeof e=="function"?e:Array.isArray(e)?e[0]:x(t,e.type)};var G=/^-[\da-z]+/i,H=/^--[\w-]{2,}/;function I(t,e=process.argv.slice(2)){let n=O(t),r={flags:E(t),unknownFlags:{},_:[]},s,f=(a,o,i)=>{let l=x(a,o);i=h(l,i),i!==void 0&&!Number.isNaN(i)?Array.isArray(r.flags[a])?r.flags[a].push(l(i)):r.flags[a]=l(i):s=g=>{Array.isArray(r.flags[a])?r.flags[a].push(l(h(l,g||""))):r.flags[a]=l(h(l,g||"")),s=void 0}},S=(a,o)=>{a in r.unknownFlags||(r.unknownFlags[a]=[]),o!==void 0?r.unknownFlags[a].push(o):s=(i=!0)=>{r.unknownFlags[a].push(i),s=void 0}};for(let a=0;a<e.length;a+=1){let o=e[a];if(o==="--"){r._.push(...e.slice(a+1));break}let i=G.test(o);if(H.test(o)||i){s&&s();let g=C(o),{flagValue:d}=g,{flagName:c}=g;if(i){for(let y=0;y<c.length;y+=1){let T=c[y],w=n.get(T),b=y===c.length-1;w?f(w.name,w.schema,b?d:!0):S(T,b?d:!0)}continue}let p=t[c];if(!p){let y=A(c);p=t[y],p&&(c=y)}if(!p){S(c,d);continue}f(c,p,d)}else s?s(o):r._.push(o)}return s&&s(),v(t,r.flags),r}module.exports=z(Q);0&&(module.exports={});
