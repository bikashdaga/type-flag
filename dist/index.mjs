const C=/-(\w)/g,E=e=>e.replace(C,(t,r)=>r.toUpperCase()),P=/\B([A-Z])/g,O=e=>e.replace(P,"-$1").toLowerCase(),{stringify:w}=JSON,{hasOwnProperty:x}=Object.prototype,d=(e,t)=>x.call(e,t),j=/^--?/,D=/[.:=]/,I=e=>{let t=e.replace(j,""),r;const i=t.match(D);if(i?.index){const n=i.index;r=t.slice(n+1),t=t.slice(0,n)}return{flagName:t,flagValue:r}},T=/[\s.:=]/,U=(e,t)=>{const r=`Invalid flag name ${w(t)}:`;if(t.length===0)throw new Error(`${r} flag name cannot be empty}`);if(t.length===1)throw new Error(`${r} single characters are reserved for aliases`);const i=t.match(T);if(i)throw new Error(`${r} flag name cannot contain the character ${w(i?.[0])}`);let n;if(C.test(t)?n=E(t):P.test(t)&&(n=O(t)),n&&d(e,n))throw new Error(`${r} collides with flag ${w(n)}`)};function L(e){const t=new Map;for(const r in e){if(!d(e,r))continue;U(e,r);const i=e[r];if(i&&typeof i=="object"){const{alias:n}=i;if(typeof n=="string"){if(n.length===0)throw new Error(`Invalid flag alias ${w(r)}: flag alias cannot be empty`);if(n.length>1)throw new Error(`Invalid flag alias ${w(r)}: flag aliases can only be a single-character`);if(t.has(n))throw new Error(`Flag collision: Alias "${n}" is already used`);t.set(n,{name:r,schema:i})}}}return t}const M=e=>!e||typeof e=="function"?!1:Array.isArray(e)||Array.isArray(e.type),z=e=>{const t={};for(const r in e)d(e,r)&&(t[r]=M(e[r])?[]:void 0);return t},A=(e,t)=>e===Number&&t===""?Number.NaN:e===Boolean?t!=="false":t,B=(e,t)=>{for(const r in e){if(!d(e,r))continue;const i=e[r];if(!i)continue;const n=t[r];if(!(n!==void 0&&!(Array.isArray(n)&&n.length===0))&&"default"in i){let o=i.default;typeof o=="function"&&(o=o()),t[r]=o}}},_=(e,t)=>{if(!t)throw new Error(`Missing type on flag "${e}"`);return typeof t=="function"?t:Array.isArray(t)?t[0]:_(e,t.type)},K=/^-[\da-z]+/i,q=/^--[\w-]{2,}/,F="--";function G(e,t=process.argv.slice(2),r={}){const i=L(e),n={flags:z(e),unknownFlags:{},_:Object.assign([],{[F]:[]})};let o;const b=(s,a,l)=>{const c=_(s,a);l=A(c,l),l!==void 0&&!Number.isNaN(l)?Array.isArray(n.flags[s])?n.flags[s].push(c(l)):n.flags[s]=c(l):o=f=>{Array.isArray(n.flags[s])?n.flags[s].push(c(A(c,f||""))):n.flags[s]=c(A(c,f||"")),o=void 0}},v=(s,a)=>{s in n.unknownFlags||(n.unknownFlags[s]=[]),a!==void 0?n.unknownFlags[s].push(a):o=(l=!0)=>{n.unknownFlags[s].push(l),o=void 0}};for(let s=0;s<t.length;s+=1){const a=t[s];if(a===F){const f=t.slice(s+1);n._[F]=f,n._.push(...f);break}const l=K.test(a);if(q.test(a)||l){o&&o();const f=I(a),{flagValue:y}=f;let{flagName:u}=f;if(l){for(let g=0;g<u.length;g+=1){const $=u[g],h=i.get($),k=g===u.length-1;h?b(h.name,h.schema,k?y:!0):r?.ignoreUnknown?n._.push(a):v($,k?y:!0)}continue}let p=e[u];if(!p){const g=E(u);p=e[g],p&&(u=g)}if(!p){r?.ignoreUnknown?n._.push(a):v(u,y);continue}b(u,p,y)}else o?o(a):n._.push(a)}return o&&o(),B(e,n.flags),n}export{G as default};
