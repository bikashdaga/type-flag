var P=/-(\w)/g,m=t=>t.replace(P,(e,r)=>r.toUpperCase()),$=/\B([A-Z])/g,j=t=>t.replace($,"-$1").toLowerCase(),{stringify:u}=JSON,{hasOwnProperty:I}=Object.prototype,F=(t,e)=>I.call(t,e),D=/^--?/,K=/[.:=]/,C=t=>{let e=t.replace(D,""),r,n=e.match(K);if(n==null?void 0:n.index){let s=n.index;r=e.slice(s+1),e=e.slice(0,s)}return{flagName:e,flagValue:r}},L=/[\s.:=]/,M=(t,e)=>{let r=`Invalid flag name ${u(e)}:`;if(e.length===0)throw new Error(`${r} flag name cannot be empty}`);if(e.length===1)throw new Error(`${r} single characters are reserved for aliases`);let n=e.match(L);if(n)throw new Error(`${r} flag name cannot contain the character ${u(n==null?void 0:n[0])}`);let s;if(P.test(e)?s=m(e):$.test(e)&&(s=j(e)),s&&F(t,s))throw new Error(`${r} collides with flag ${u(s)}`)};function E(t){let e=new Map;for(let r in t){if(!F(t,r))continue;M(t,r);let n=t[r];if(n&&typeof n=="object"){let{alias:s}=n;if(typeof s=="string"){if(s.length===0)throw new Error(`Invalid flag alias ${u(r)}: flag alias cannot be empty`);if(s.length>1)throw new Error(`Invalid flag alias ${u(r)}: flag aliases can only be a single-character`);if(e.has(s))throw new Error(`Flag collision: Alias "${s}" is already used`);e.set(s,{name:r,schema:n})}}}return e}var R=t=>!t||typeof t=="function"?!1:Array.isArray(t)||Array.isArray(t.type),v=t=>{let e={};for(let r in t)F(t,r)&&(e[r]=R(t[r])?[]:void 0);return e},h=(t,e)=>t===Number&&e===""?Number.NaN:t===Boolean?e!=="false":e,_=(t,e)=>{for(let r in t){if(!F(t,r))continue;let n=t[r];if(!n)continue;let s=e[r];if(!(s!==void 0&&!(Array.isArray(s)&&s.length===0))&&"default"in n){let g=n.default;typeof g=="function"&&(g=g()),e[r]=g}}},A=(t,e)=>{if(!e)throw new Error(`Missing type on flag "${t}"`);return typeof e=="function"?e:Array.isArray(e)?e[0]:A(t,e.type)};var z=/^-[\da-z]+/i,B=/^--[\w-]{2,}/,x="--";function U(t,e=process.argv.slice(2)){let r=E(t),n={flags:v(t),unknownFlags:{},_:Object.assign([],{[x]:[]})},s,g=(a,o,i)=>{let l=A(a,o);i=h(l,i),i!==void 0&&!Number.isNaN(i)?Array.isArray(n.flags[a])?n.flags[a].push(l(i)):n.flags[a]=l(i):s=c=>{Array.isArray(n.flags[a])?n.flags[a].push(l(h(l,c||""))):n.flags[a]=l(h(l,c||"")),s=void 0}},S=(a,o)=>{a in n.unknownFlags||(n.unknownFlags[a]=[]),o!==void 0?n.unknownFlags[a].push(o):s=(i=!0)=>{n.unknownFlags[a].push(i),s=void 0}};for(let a=0;a<e.length;a+=1){let o=e[a];if(o===x){let c=e.slice(a+1);n._[x]=c,n._.push(...c);break}let i=z.test(o);if(B.test(o)||i){s&&s();let c=C(o),{flagValue:d}=c,{flagName:f}=c;if(i){for(let y=0;y<f.length;y+=1){let b=f[y],w=r.get(b),T=y===f.length-1;w?g(w.name,w.schema,T?d:!0):S(b,T?d:!0)}continue}let p=t[f];if(!p){let y=m(f);p=t[y],p&&(f=y)}if(!p){S(f,d);continue}g(f,p,d)}else s?s(o):n._.push(o)}return s&&s(),_(t,n.flags),n}export{U as default};
